# -*- coding: utf-8 -*-
"""2_23

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bU60As31or0dtPfX6kP1EfEKVN5kAtoh

# Python Bootcamp: Assignment 3 [100 points]

This week we will start writing some code! This assignment is designed to be a crash-course to get you up to speed on the level of Python you will need to know in order to do the remainder of the assignments. It's easiest to learn by doing, so please start early so we can help you get on board. You want to spend the semester focusing on the crowdsourcing and machine learning, not the indenting and semicoloning.

Before you do anything save a copy of this file in Drive (found in File) and work on that one.
"""

import pandas as pd
df = pd.read_csv('batch.csv')
df.head()

"""## 1. Working with Lists [15 points]

1. **[5 points]** Consider the function `extract_and_apply(l, p, f)` shown below, which extracts the elements of a list `l` satisfying a boolean predicate `p`, applies a function f to each such element, and returns the result.

  Rewrite `extract_and_apply(l, p, f)` in one line using a list comprehension.
"""

def extract_and_apply(l, p, f):
     result = []
     for x in l:
         if p(x):
             result.append(f(x))
     return result

l = [1, 2, 3, 4]
p = lambda x: x % 2 == 0
f = lambda x: x

result = extract_and_apply(l, p, f)
print(result)

def extract_and_apply(l, p, f):
    return [f(x) for x in l if p(x)]

# # Example:
# l = [1, 2, 3, 4]
# p = lambda x: x % 2 == 0
# f = lambda x: x
# extract_and_apply(l, p, f)

# # Expected output:
# # [2, 4]

"""2. **[5 points]** Write a function `concatenate(seqs)` that returns a list containing the concatenation of the elements of the input sequences. Your implementation should consist of a single list comprehension, and should not exceed one line.


"""

def concatenate(seqs):
    pass

# # Example:
# concatenate([[1, 2], [3, 4]])

# # Expected output:
# # [1, 2, 3, 4]

result = concatenate([[1, 2], [3, 4]])
def concatenate(seqs):
    return [element for seq in seqs for element in seq]
print(result)

# # Example:
# concatenate(["abc", (0, [0])])

# # Expected output:
# # ['a', 'b', 'c', 0, [0]]

result = concatenate(["abc", (0, [0])])
def concatenate(seqs):
    return [element for seq in seqs for element in seq]
print(result)

"""3. **[5 points]** Write a function `transpose(matrix)` that returns the transpose of the input matrix, which is represented as a list of lists. Recall that the transpose of a matrix is obtained by swapping its rows with its columns. More concretely, the equality `matrix[i][j] == transpose(matrix)[j][i`] should hold for all valid indices `i` and `j`. You may assume that the input matrix is well-formed, i.e., that each row is of equal length. You may further assume that the input matrix is non-empty. Your function should not modify the input."""

def transpose(matrix):
  result = []
  for i in range(len(matrix[0])):
    row = []
    for j in range(len(matrix)):
      row.append(matrix[j][i])
    result.append(row)
  return result

print(transpose([[1, 2, 3]]))

# # Example:
# transpose([[1, 2, 3]])

# # Expected output:
# # [[1], [2], [3]]

def transpose(matrix):
  result = []
  for i in range(len(matrix[0])):
    row = []
    for j in range(len(matrix)):
      row.append(matrix[j][i])
    result.append(row)
  return result

print(transpose([[1, 2], [3, 4], [5, 6]]))

# # Example:
# transpose([[1, 2], [3, 4], [5, 6]])

# # Expected output:
# # [[1, 3, 5], [2, 4, 6]]

"""## 2. Sequence Slicing [9 points]

The functions in this section should be implemented using sequence slices. Recall that the slice parameters take on sensible default values when omitted. In some cases, it may be necessary to use the optional third parameter to specify a step size.

1. **[3 points]** Write a function `copy(seq)` that returns a new sequence containing the same elements as the input sequence.
"""

def copy(seq):
    return seq[:]

result = copy("abc")

print(result)

# # Example:
# copy("abc")

# # Expected output:
# # 'abc'

def copy(seq):
    return seq[:]

result = copy((1, 2, 3))

print(result)

# # Example:
# copy((1, 2, 3))

# # Expected output:
# #  (1, 2, 3)

def copy(seq):
    return seq[:]

x = [0, 0, 0]
y = copy(x)
print(x, y)

x[0] = 1
print(x, y)

# # Example:
# x = [0, 0, 0]
# y = copy(x)
# print(x, y)

# x[0] = 1
# print(x, y)

# # Expected output:
# # [0, 0, 0] [0, 0, 0]
# # [1, 0, 0] [0, 0, 0]

"""2. **[3 points]** Write a function `all_but_last(seq)` that returns a new sequence containing all but the last element of the input sequence. If the input sequence is empty, a new empty sequence of the same type should be returned. bold text"""

def all_but_last(seq):
    return seq[:-1]
result = all_but_last("abc")
print(result)

# # Example:
# all_but_last("abc")

# # Expected output:
# # 'ab'

def all_but_last(seq):
    return seq[:-1]
result = all_but_last((1, 2, 3))
print(result)

# # Example:
# all_but_last((1, 2, 3))

# # Expected output:
# # (1, 2)

def all_but_last(seq):
    return seq[:-1]
result = all_but_last("")
print(result)

# # Example:
# all_but_last("")

# # Expected output:
# # ''

def all_but_last(seq):
    return seq[:-1]
result = all_but_last([])
print(result)

# # Example:
# all_but_last([])

# # Expected output:
# # []

"""3. **[3 points]** Write a function `every_other(seq)` that returns a new sequence containing every other element of the input sequence, starting with the first. This function can be written in one line using the optional third parameter of the slice notation."""

def every_other(seq):
    return seq[::2]
result = every_other([1, 2, 3, 4, 5])
print(result)

# # Example:
# every_other([1, 2, 3, 4, 5])

# # Expected output:
# # [1, 3, 5]

def every_other(seq):
    return seq[::2]
result = every_other("abcde")
print(result)

# # Example:
# every_other("abcde")

# # Expected output:
# # 'ace'

def every_other(seq):
    return seq[::2]
result = every_other([1, 2, 3, 4, 5, 6])
print(result)

# # Example:
# every_other([1, 2, 3, 4, 5, 6])

# # Expected output:
# # [1, 3, 5]

def every_other(seq):
    return seq[::2]
result = every_other("abcdef")
print(result)

# # Example:
# every_other("abcdef")

# # Expected output:
# # 'ace'

"""## 3. Combinatorial Algorithms [12 points]

The functions in this section should be implemented as generators. You may generate the output in any order you find convenient, as long as the correct elements are produced. However, in some cases, you may find that the order of the example output hints at a possible implementation.

Although generators in Python can be used in a variety of ways, you will not need to use any of their more sophisticated features here. Simply keep in mind that where you might normally return a list of elements, you should instead yield the individual elements.

Since the contents of a generator cannot be viewed without employing some form of iteration, we wrap all function calls in this sectionâ€™s examples with the list function for convenience.

1. **[6 points]** The prefixes of a sequence include the empty sequence, the first element, the first two elements, etc., up to and including the full sequence itself. Similarly, the suffixes of a sequence include the empty sequence, the last element, the last two elements, etc., up to and including the full sequence itself. Write a pair of functions `prefixes(seq)` and `suffixes(seq)` that yield all prefixes and suffixes of the input sequence.
"""

def prefixes(seq):
    for i in range(len(seq) + 1):
        yield seq[0:i]
result = list(prefixes([1, 2, 3]))
print(result)

def suffixes(seq):
    for i in range(len(seq)+1):
      yield seq[i:]

result = list(prefixes([1, 2, 3]))
print(result)

# # Example:
# list(prefixes([1, 2, 3]))

# # Expected output:
# # [[], [1], [1, 2], [1, 2, 3]]

# # Example:
# list(suffixes([1, 2, 3]))

# # Expected output:
# # [[1, 2, 3], [2, 3], [3], []]

def prefixes(seq):
    for i in range(len(seq) + 1):
        yield seq[0:i]
result = list(prefixes("abc"))
print(result)

# # Example:
# list(prefixes("abc"))

# # Expected output:
# # ['', 'a', 'ab', 'abc']

def suffixes(seq):
    for i in range(len(seq)+1):
      yield seq[i:]

result = list(suffixes("abc"))
print(result)

# # Example:
# list(suffixes("abc"))

# # Expected output:
# # ['abc', 'bc', 'c', '']

"""2. **[6 points]** Write a function `slices(seq)` that yields all non-empty slices of the input sequence."""

def slices(seq):
    for start in range(len(seq)):
        for end in range(start + 1, len(seq) + 1):
            yield seq[start:end]
result = list(slices([1, 2, 3]))
print(result)

# # Example:
# list(slices([1, 2, 3]))

# # Expected output:
# # [[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]]

def slices(seq):
    for start in range(len(seq)):
        for end in range(start + 1, len(seq) + 1):
            yield seq[start:end]
result = list(slices("abc"))
print(result)

# # Example:
# list(slices("abc"))

# # Expected output:
# # ['a', 'ab', 'abc', 'b', 'bc', 'c']

"""1. **[5 points]** A common preprocessing step in many natural language processing tasks is text normalization, wherein words are converted to lowercase, extraneous whitespace is removed, etc. Write a function `normalize(text)` that returns a normalized version of the input string, in which all words have been converted to lowercase and are separated by a single space. No leading or trailing whitespace should be present in the output."""

def normalize(text):
    return " ".join(text.lower().split())

result = normalize("This is an example.")
print(result)

# # Example:
# normalize("This is an example.")

# # Expected output:
# # 'this is an example.'

def normalize(text):
    return " ".join(text.lower().split())

result = normalize("   EXTRA   SPACE   ")
print(result)

# # Example:
# normalize("   EXTRA   SPACE   ")

# # Expected output:
# # 'extra space'

"""2. **[5 points]** Write a function `no_vowels(text)` that removes all vowels from the input string and returns the result. For the purposes of this problem, the letter â€˜yâ€™ is not considered to be a vowel.


"""

def no_vowels(text):
    vowels = "aeiouAEIOU"
    result = ""
    for letter in text:
      if letter not in vowels:
         result += letter
    return result

words = no_vowels("This Is An Example.")
print(words)

# # Example:
# no_vowels("This Is An Example.")

# # Expected output:
# # 'Ths s n xmpl.'

def no_vowels(text):
  vowels = "aeiouAEIOU"
  result = ""
  for letter in text:
    if letter not in vowels:
      result = result + letter
  return result
result = no_vowels("We love Python!")
print(result)

# # Example:
# no_vowels("We love Python!")

# # Expected output:
# # 'W lv Pythn!'

"""3. **[5 points]** Write a function `digits_to_words(text)` that extracts all digits from the input string, spells them out as lowercase English words, and returns a new string in which they are each separated by a single space. If the input string contains no digits, then an empty string should be returned."""

def digits_to_words(text):
    digits_words = {
        '0': 'zero', '1': 'one', '2': 'two', '3': 'three',
        '4': 'four', '5': 'five', '6': 'six',
        '7': 'seven', '8': 'eight', '9': 'nine'
    }
    result = []
    for i in text:
      if i.isdigit():
         result.append(digits_words[i])
    return ' '.join(result)
digits_to_words("Zip Code: 19104")

# # Example:
# digits_to_words("Zip Code: 19104")

# # Expected output:
# # 'one nine one zero four'

def digits_to_words(text):
    digit_map = {
        '0': 'zero', '1': 'one', '2': 'two', '3': 'three',
        '4': 'four', '5': 'five', '6': 'six',
        '7': 'seven', '8': 'eight', '9': 'nine'
    }
    result = []
    for i in text:
        if i.isdigit():
            result.append(digit_map[i])
    return ' '.join(result)
digits_to_words("Pi is 3.1415...")

# # Example:
# digits_to_words("Pi is 3.1415...")

# # Expected output:
# # 'three one four one five'

"""4. **[5 points]** Although there exist many naming conventions in computer programming, two of them are particularly widespread. In the first, words in a variable name are separated using underscores. In the second, words in a variable name are written in mixed case, and are strung together without a delimiter. By mixed case, we mean that the first word is written in lowercase, and that subsequent words have a capital first letter. Write a function `to_mixed_case(name)` that converts a variable `name` from the former convention to the latter. Leading and trailing underscores should be ignored. If the variable name consists solely of underscores, then an empty string should be returned.


"""

def to_mixed_case(name):
    stripped = name.strip('_')
    if not stripped:
        return ''
    parts = stripped.split('_')
    return parts[0].lower() + ''.join(word.capitalize() for word in parts[1:])
result = to_mixed_case("__EXAMPLE__NAME__")
result

# # Example:
# to_mixed_case("__EXAMPLE__NAME__")

# # Expected output:
# # 'exampleName'

"""## 5. DataFrames [44 points]
In this section you'll get a feel for pandas' DataFrames a datastructure similar to SQL tables that can directly read lists and csvs and supports a number of optimized operations.

### 5.1 Manipulating a csv [30 points]
"""

# first we'll import pandas
import pandas as pd

"""1. **[2 points]** In the method `read_file` create a dataframe from the given csv file."""

# hint: look at the pandas method read_csv
def read_file(filename):
    df = pd.read_csv(filename)
    return df
data = read_file("batch.csv")
data



df = read_file('batch.csv')

"""batch.csv is a csv of the results from a batch of HITs on MTurk. With it you can see worker Ids, their answers to each question, as well as their accept and submit times.

Comment the cells below out before you submit.
"""

# you can also get a smaller glimpse with
display (df.head())

# or just the columns with
display (df.columns)

# a slice of a dataframe is called a series. for example:
display (df['HITId'])

"""2. **[3 points]** Write the method `get_workerId_by_row` that returns the Worker ID at the given row in the dataframe.

> Add blockquote


"""

def get_workerId_by_row(df, row_index):
    return df.loc[row_index, 'WorkerId']
result = get_workerId_by_row(df, 3)
result

# EXAMPLE
# get_workerId_by_row(df, 3)
# 'A98E8M4QLI9RS'

"""3. **[5 points]** In the method `format_date` convert a datetime string from the format Year-Month-Day Hour-Minute-Second to a timestamp in minutes."""

from datetime import datetime

def format_date(date):
    if isinstance(date, (int, float)):
       return int(date)
    elif isinstance(date, str):

       dt = datetime.strptime(date, "%Y-%m-%d %H:%M:%S")
       timestamp_seconds = int(dt.timestamp())
    return timestamp_seconds

result = format_date('2020-02-06 23:25:41')
result

# EXAMPLE
# format_date('2020-02-06 23:25:41') -> 26350525.683333334

"""4. **[5 points]** Use the `format_date` method to convert each entry in `SubmitTime` and `AcceptTime` into a timestamp. In `convert_times` return the series you get by applying that method to each entry in the given column"""

def convert_times(df, column_name):
    return df[column_name].apply(format_date)

submit_timestamps = convert_times(df,'SubmitTime')
submit_timestamps

accept_time = convert_times(df, 'AcceptTime')
accept_time

df['SubmitTime'] = convert_times(df, 'SubmitTime')

df['AcceptTime'] = convert_times(df, 'AcceptTime')

"""5. **[5 points]** In `get_work_time` figure out how long each worker spent on the batch. Return the series that is the total work time indexed by the worker id."""

def get_work_time(df):

    submit = pd.to_numeric(df['SubmitTime'], errors='coerce')
    accept = pd.to_numeric(df['AcceptTime'], errors='coerce')

    df['WorkTime'] = accept - submit


    return df.groupby('WorkerId')['WorkTime'].sum()

work_time_series = get_work_time(df)
work_time_series

# EXAMPLE
# Should be a series like
# Time
# Time

"""6. **[10 points]** As we talked about in class workers can use tools to accept batches of HITs at once and then work on them sequentially. We suspect some of the workers in this batch have been using such a tool and that their work times overestimate how long they actually spent working. Write a method to calculate how long each worker actually spent working.

Hint: try to think about a worker's accept and submit times would look like if they were doing this and any overlap you might be able to find.
"""

def calculated_work_time(df):
    df['AcceptTime'] = df['AcceptTime'].apply(format_date)
    df['SubmitTime'] = df['SubmitTime'].apply(format_date)

    actual_times = {}

    for worker, group in df.groupby('WorkerId'):
        # Sort intervals by AcceptTime
        intervals = group[['AcceptTime', 'SubmitTime']].sort_values('AcceptTime').values.tolist()

        merged = []
        for start, end in intervals:
            if not merged or start > merged[-1][1]:
                merged.append([start, end])
            else:
                merged[-1][1] = max(merged[-1][1], end)

        # Sum non-overlapping durations
        total = sum(end - start for start, end in merged)
        actual_times[worker] = total

    return pd.Series(actual_times)

work_time_series = calculated_work_time(df)
work_time_series

# EXAMPLE
# Series should look the same as above but with different values for some workers

"""7. **[0 points]** Here we'll show you how you can plot the data you just looked at.

Comment all of this out before you submit.
"""

plot_df = pd.DataFrame()

plot_df['CWorkTime'] = calculated_work_time(df)

plot_df.plot(kind='bar')

"""### 5.2 A Simple Program to Read from the Web [14 points]

The cell below uses the Pandas library to read a table from the given web page (the Wikipedia information on films in the year 2010). The code loads this into a list of DataFrames called films_2010. We then pull the table at index 3, then do some simple data wrangling on top_films to set up the appropriate types.

Run the cells below.
"""

!pip install money-parser

import pandas as pd
from money_parser import price_dec

"""**TODO:** Read in a list of dataframes from the url https://en.wikipedia.org/wiki/2010_in_film

*Hint:* Check the pandas documentation
"""

import pandas as pd
import requests

def read_from_html(url):
    headers = {'User-Agent': 'Mozilla/5.0'}
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    tables = pd.read_html(response.text)
    return tables
url = "https://en.wikipedia.org/wiki/2010_in_film"
tables = read_from_html(url)
tables

films_2010 = read_from_html('https://en.wikipedia.org/wiki/2010_in_film')

"""# **TODO:** Find the table titled "Highest-grossing films"

*Hint:* Click on the url, and do some digging! Check out "Developer Tools" for the underlying html code and check which  < table >  tag contains the desired data
"""

def get_film_data(df_list):
    for df in df_list:
        if isinstance(df.columns, pd.MultiIndex):
            flat_columns = [' '.join(map(str, col)).lower() for col in df.columns]
        else:
            flat_columns = [str(col).lower() for col in df.columns]
        if any('title' in col for col in flat_columns) and any('gross' in col for col in flat_columns):
            df.columns = flat_columns
            return df
    return None
highest_grossing = get_film_data(tables)
highest_grossing

top_films = get_film_data(films_2010)

"""**TODO:** write a method that sets the 'Rank' column as the index

---


"""

def set_index(df, column_hint='rank'):
    for col in df.columns:
        if column_hint.lower() in str(col).lower():
            return df.set_index(col)
ranked_df = set_index(highest_grossing)
ranked_df

top_films_ranked = set_index(top_films, 'Rank')
top_films_ranked

"""**TODO:** write a function that creates a column named 'Revenue (millions)', where the revenue in millions (rounded to 2 decimal places) are to be stored.

*Hint:* We recommend you use the imported function from the 'money_parser' module (see above).
"""

print(df.columns)

def extract_revenue(df, column, name):
    df[name] = (
        df[column]
        .astype(str)
        .str.replace(r'[^\d.]', '', regex=True)
        .astype(float) / 1_000_000
    ).round(2)
    return df

df = extract_revenue(df, column='Reward', name='Reward (millions)')
print(df[['Reward', 'Reward (millions)']].head())

top_films_revenue = extract_revenue(top_films_ranked, 'worldwide gross', 'Revenue (millions')

"""Can we programmatically compute how many entries were scored as top films?

You can use the Python shape function on a dataframe to determine the dimensions!
To learn more about the shape function, you can search for its pandas documentation.

**TODO:** Create a function that calculates the shape of the final dataframe (top_films_revenue) and returns a tuple
"""

def get_dimensions(df):
    return df.shape
dimensions = get_dimensions(top_films_revenue)
dimensions